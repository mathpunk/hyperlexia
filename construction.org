#+TITLE: The Anansi Initiative
#+AUTHOR: thomas H. (first)
---




Let us:

- specify
- test
- view
- serve

and then move on. 

* Literate Specification

*Technology*: Clojure.spec, by Rich Hickey and others. Provide URL.

As a mathematician who likes programming, it is very tempting to want to bring type theory into my projects. But as a mathematician who is also a poet, I know that it is possible to express more than you can ever prove. 

Hence my attraction to =clojure.spec=, a project in development this year (2016) that is a method for doing regular-expression-style algebra (half-remembered reference: Look up Kleene closures?) on boolean functions. So it's like types in that you can dispatch functions on whether a thing, oh let's say,  IS or IS NOT a q-rhomboidal framizdat, a very important collection of letters I just made up, provided that someone can hand you a definition of just what it means to be or not be such a framizdat. 

This seems good*. I'm giving it a try.

*- 1) It eats type theory. 2) It could generate its own unit tests, => automated programming potential, i.e., the "teach a NN to pass a unit test" trick. 3) I can imagine, though do not know how to implement, generalizations to fuzzy type theory. 


* Visual REPL

*Technology*: Devcards, by Bruce Hauman and others. Provide URL.

Ugh, command line, right? It's crazy powerful but it's just....... letters! 

So I'm going to try doing all my tests in the visual style afforded by devcards. You can write tests in it to look at your logic, and you can write little bits of UI. You can also use the generative methods that =clojure.spec= provides to create a mess of test data so that you can look for edge conditions in which your UI looks like crap. Cool. (Refer to that Juxt blog post.)


* Names

  First, names for things. I'm permitting myself to be verbose in the definitions of important notions. I'll try to get in some Components and Tests as well as Names as I go along.

** Items

Items, Pins, and Hrefs: What it is to be an item
------------------------------------------------

   An item is something that may be identified.

#+BEGIN_SRC clojure :tangle src/hyperlexia/item.cljc

(ns hyperlexia.item
  (:require #?(:clj [clojure.spec :as s]
               :cljs [cljs.spec :as s])))

;; Identifiable
(defprotocol Identifiable (id [x] "Return a context-appropriate unique identifier."))

(s/def ::item (s/or :has-key (s/keys :req-un [::id]) :has-fn #(satisfies? Identifiable %)))
;; thank clojurians.spec@alexmiller

#+END_SRC

Our first instance of such an item is 'the bookmark.' My first observation is that every bookmark storage solution I've seen always looks kludgy, or else is susceptible to the data extortion and lack of data liberation fronts. (Google does well here, having an actual team for it.) 

My second observation is, why are they called bookmarks?, when they do not generally represent a marker of progress through a book, nor do they tend to mean markers of passages within a book. 

So anyway the name seems terrible. Looking about for a suitable replacement, I notice that the word 'pin', and the icon for a pushpin, has come to mean something like my use case. I want to 'put a pin in' some clipping or notion for later. I may even have a concept of what space of notional 'wall' or 'board' I would pin it in, to come across later. 

Since this pinning notion works for moodboards, for agenda items, & for the many users of Pinterest and Pinboard, I'm grabbing the word and defining it to just mean: it's a thing with a link in it. 

#+BEGIN_SRC clojure :tangle src/hyperlexia/item.cljc

  (s/def ::href (s/and string? #(re-matches #"https?://.*" %)))
  (s/def ::pin (s/keys :req [::href]))

#+END_SRC

(Mind you, there's some way that you can refer to local files in the same way as remote files, b/c it turns out that "file:///home/person/some-data/data.txt" is a "uri." Only, I don't know the difference so I'm starting with just "stuff on the web", using regular expression algebra on filthy characters, and I'll worry about local items when and if the time comes.) 


*** First Tests

    Now let's start testing the code with devcards. Now, I'm pretty sure that devcards lets you do this in each namespace individually, but I'm not sure if I have the code structured right? Let's just set everything up in core for now. 

 Let me take a moment to note rad libraries I was using on the first draft that I will leave out of the next namespace declaration. 
 
           [rum.mdl :as mdl]
           [cljs.pprint :refer [pprint]]
           [hyperlexia.data :refer [likes]]

 #+BEGIN_SRC clojure :tangle src/hyperlexia/core.cljs

 (ns hyperlexia.core
   (:require [sablono.core :as sab :include-macros true]
             [cljs.test :refer [testing is]]
             [cljs.spec :as s]
             [hyperlexia.item :as item]
             [rum.core :as rum :refer [defc]])
   (:require-macros
    [devcards.core :as dc :refer [defcard deftest]]))

 (enable-console-print!)

 #+END_SRC

 Also note, I'm interested in trying rum out over sablono, when I tried removing the sablono dependency the cards themselves broke, I took a whole 10 seconds to diagnose why and didn't get anywhere so I'm just leaving in double-React wrappers until I get somewhere more interesting looking and take the time to fix it. Very pro. 

 #+BEGIN_SRC clojure :tangle src/hyperlexia/core.cljs

     (deftest href-specifications
       (testing "string URLs"
         (is (s/valid? :hyperlexia.item/href "https://twitter.com"))
         (is (not (s/valid? :hyperlexia.item/href "hi there")))))

 #+END_SRC

 That's our first test. Downpage, there's a little bit of boilerplate to run devcards. The tests pass!


*** A more concrete item: Tweets

    Tweets are a kind of pin that I find in: my journal files, my notes files, my browser tabs, my clipboard, having yanked them from my browser tab to try and put them somewhere, anywhere, oh my god where do they go. So that is, they come to me as strings, but they have some meaning attached that I want to get at: their social meaning, through their author and the author's tweets & bio and the author's friends; and the text they contain, which must be server-fetched in order to be stored & analyzed.

Identifying and destructuring
-----------------------------

    Tweets are granted id's by the Twitter.com corporation. Their authorship is given by an author's Twitter.com service name, a name registed by humans and agents by the leave of the Twitter.com corporation. All of this information is contained in the tweet's href.

 #+BEGIN_SRC clojure :tangle src/hyperlexia/item.cljc

   (def tweet-regex #"https?://twitter.com/(\w+)/status/(\d+)")
   (s/def ::tweet-url (s/and string? #(re-matches tweet-regex %)))

   (s/def ::tweet (s/and ::pin #(s/valid? ::tweet-url (:href %))))
   (deftest twitter-href-specification
     (testing "twitter URLs"
       (is (s/valid? ::tweet-url "https://twitter.com/zeynep/status/803256287622549504"))
       (is (not (s/valid? ::tweet-url "hi there")))
       (is (not (s/valid? ::tweet-url "https://thenewyorktimes.com")))))

 #+END_SRC

Hm. Since the information is contained in the tweet's ref, then to make a =tweet-url= into a =tweet= object, why not use a =make-= function, and skip all this nonsense about protocols. (Also, let's see if we can't go ahead and discover namespaced devcards through power of naivete.) 

  #+BEGIN_SRC clojure  

    (s/def ::tweet (s/and ::pin #(s/valid? ::tweet-url (:href %))))

    (defn make-tweet [href]
      (let [regex #"https://twitter.com/(\w+)/status/(\d+).*"]
        (if-let [matches (first (re-seq regex href))
                 id (nth matches 2)
                 user (nth matches 1)]
          {:href href
           :user user
           :id id}
          nil)))

  #+END_SRC

And we test that...

#+BEGIN_SRC clojure :tangle src/hyperlexia/item.cljc

  (deftest tweet-destructuring
    (testing "url -> tweet with data"
      (let [href "https://twitter.com/zeynep/status/803256287622549504"
            tweet (make-tweet href)]
        (is (= "zeynep" (:user tweet)))
        (is (or (= 803256287622549504 (:id tweet))
                (= "803256287622549504" (:id tweet)))))))

#+END_SRC

Retrieving tweet data from the Twitter.com corporation: Hacking the Gibson
--------------------------------------------------------------------------

    Bearing in mind tendency for the silk of the web to rot, and the relatively slimness of the volume of data we've flagged as worth consideration, we should really host this volume in our own databases. Because of restrictions on what browsers can do, this will have to be server-side code.


**** Tweet workflows

 Want to get tweets out of:
  :journal
  :notes
  :clipboard / :pastein


*** Files, Paths

 The time will come when you will want your local files, which you have written by hand or hosted at your own expense, to be considered as items.

 #+BEGIN_SRC clojure

    (s/def ::path #?(:clj #(clojure.java.io/as-relative-path %)
                     :cljs string?))
    (s/def ::file (s/keys (s/or ::path
                                (s/and vector? (s/coll-of ::path)))))
 #+END_SRC


*** Other potential items, id methods, identifiables

     Methods by which we might identify
     - is it in the url? :tweet
     - is it from pinboard? use pinboard's hash :pinboard
     - is it on a file system we control? :path
     - wait that's for any file system --- want to just do :path and /hope/ you control it?
     - is it identified by its contents? :hash-tree-able
     - is it a document with fields? clojure data structures are hashable (immutable!)

  Items
  -----
  Items can be identified.
  id tweet -> [status (re-matches...)]
  id pin -> :hash %
  id file -> sha1 content


** Labels

Labels, Keywords, Terms, Topics: What it is to be a label
---------------------------------------------------------

It is our prerogative to label items however we wish with as many labels as we wish.

- keywords :: words that have descriptive meaning for us
- terms :: synonym of keywords; to remind us that we permit space-separated keywords
- tags :: another synonym
- topics :: not quite a synonym, being a set (possibly singleton) from the keywords
- decorations :: a label that you cannot describe in language. A song, an image, any other way of meaning. Please provide a uri that we might use the resource when displaying a decorated item. 


Tags are a set of terms, or a comma-separated string of terms. Something that is tagged, it has a nonblank string or nonempty set of terms.

#+BEGIN_SRC clojure

  (s/def ::tags (s/or :string string? :set set?))
  (s/def ::tagged (s/and (s/keys :req [::tags])
                         #(apply (complement empty?) [(:tags %)])))

#+END_SRC

** Render

Rendering the App and/or the Devcards
-------------------------------------

   If you want a simple server, set it up in the =project.clj=. For now, we've just got what the devcards template suggests.

#+BEGIN_SRC clojure :tangle src/hyperlexia/core.cljs

(defn main []
  ;; conditionally start the app based on whether the #main-app-area
  ;; node is on the page
  (if-let [node (.getElementById js/document "main-app-area")]
    (.render js/ReactDOM (sab/html [:div "This is working"]) node)))

(main)

#+END_SRC

* Components

First a test tweet with like, maybe the fields we use? Followed by an all-text component.

#+BEGIN_SRC clojure

  (defcard tweet-fields
    "At least, maybe"
  { :timestamp "2016-11-11"
            :user "MadeUpHuman"
            :id 1234123412341234
            :type :tweet
            :href "https://twitter.com/MadeUpMan/status/1234123412341234" } )

;; here was a component sketch when material-ui wasn't working (still isn't so far as i know)
  #_(defc tweet [pin]
    [:li (:user pin ) " | " [:a {:href (:href pin)} "tweet"] " | " " { first tag, second }" ]
    )



#+END_SRC


* Tests

  I enjoyed setting up tests right by the specs. Can you come up with further tests?
* Next
** Data Sources
   Twitter, because it has stolen masses of my attention. Evernote dump, because it was the origin of the project. Locally stored writings, because I seek to turn them into essays or pitches or poems or, god, some proof that I was alive on the planet for one brief moment of 40 or 80 or 120 years. Whatever else I can think of, likely mediated through some other service for organizing them in a beautiful way -- by this what I mean is, put it all on Plex and then do tricks on the paths to the data that I host and the content-hashes of data that I do not host. 

** Items & Labels

We host or reference items, and we label them as we wish. 

   The point of all this is to get to the point where it makes sense to implement the concept lattice functions & protocols found in this Order Theory book I straight up stole from Multnomah. I promise to pay them back. I have to go in for forgiveness. I also have to ask Eric WVGG if he has that book and if so to mail it to 849 N Farragut toot suite. (Or should he keep it?) 

Another point is to distinguish between my labels and your labels --- to import your labels, disagree with your labels, modify your labels, combine our labels, annote subjunctive labels. To do interesting things with the ways that we reshuffle things by the way that we name them (or perhaps we should say 'multiname them'? nah it'll never catch on). 

Another another point is to take those concept lattice functions, and derive transformations from mathematical work that has been done on them in the abstract. It is my understanding that there are graph drawing methods to represent concepts, subconcepts, and superconcepts in rather continuous ways. That would be a big help in exploring a large collection of items or, dually, a large collection of collections of labels. 
** Contexts, Workflows
;; Contexts
;; --------

;; Morning message

;; Morning structure

;; Evening message

;; Evening structure

** Network Rethinks

I'm always on the lookout for ways to use p2p concepts and new methods in computronium. FileCoin? Tezos? Akasha? Datasys? Dat Sys? Other experimental services? I'm down to experiment. 


