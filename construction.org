#+TITLE: The Anansi Initiative
#+AUTHOR: thomas H. (first)
---




Let us:

- specify
- test
- view
- serve

and then move on. 

* Literate Specification

*Technology*: Clojure.spec, by Rich Hickey and others. Provide URL.

As a mathematician who likes programming, it is very tempting to want to bring type theory into my projects. But as a mathematician who is also a poet, I know that it is possible to express more than you can ever prove. 

Hence my attraction to =clojure.spec=, a project in development this year (2016) that is a method for doing regular-expression-style algebra (half-remembered reference: Look up Kleene closures?) on boolean functions. So it's like types in that you can dispatch functions on whether a thing, oh let's say,  IS or IS NOT a q-rhomboidal framizdat, a very important collection of letters I just made up, provided that someone can hand you a definition of just what it means to be or not be such a framizdat. 

This seems good*. I'm giving it a try.

*- 1) It eats type theory. 2) It could generate its own unit tests, => automated programming potential, i.e., the "teach a NN to pass a unit test" trick. 3) I can imagine, though do not know how to implement, generalizations to fuzzy type theory. 


* Visual REPL

*Technology*: Devcards, by Bruce Hauman and others. Provide URL.

Ugh, command line, right? It's crazy powerful but it's just....... letters! 

So I'm going to try doing all my tests in the visual style afforded by devcards. You can write tests in it to look at your logic, and you can write little bits of UI. You can also use the generative methods that =clojure.spec= provides to create a mess of test data so that you can look for edge conditions in which your UI looks like crap. Cool. (Refer to that Juxt blog post.)


* Let's Try It

** What it is to be an item

   An item is something that may be identified.

   Identifiable

   methods by which we might identify
   - is it in the url? :tweet
   - is it on a file system we control? :path
   - is it identified by its contents? :hash-tree-able
   - is it a document with fields? clojure data structures are hashable (immutable!)
   
The first concrete thing we care about are 'tweets', which are granted an id by the Twitter.com corporation. Bearing in mind tendency for the silk of the web to rot, and the relatively slimness of the volume of data we've flagged as worth consideration, we should host this volume in our own databases. 


IMPLEMENTATIONS
===============
1. For tweets, so I can do twitter & link analysis
2. For arbitrary links, though I see no reason not to separate hosts again.
3. Then do paths so I can do my own file system.
4. About now is when you'd want to consider automated agents or else switch to your filesys analysis idea -- for every path, collect into one set the paths with the same sha1 as a first pass, and for content-similarity as another pass.



** What it is to be a label 

It is our prerogative to label items however we wish with as many labels as we wish.

- keywords :: words that have descriptive meaning for us
- terms :: synonym of keywords; to remind us that we permit space-separated keywords
- tags :: another synonym
- topics :: not quite a synonym, being a set (possibly singleton) from the keywords
- decorations :: a label that you cannot describe in language. A song, an image, any other way of meaning. Please provide a uri that we might use the resource when displaying a decorated item. 






** Data Sources
   Twitter, because it has stolen masses of my attention. Evernote dump, because it was the origin of the project. Locally stored writings, because I seek to turn them into essays or pitches or poems or, god, some proof that I was alive on the planet for one brief moment of 40 or 80 or 120 years. Whatever else I can think of, likely mediated through some other service for organizing them in a beautiful way -- by this what I mean is, put it all on Plex and then do tricks on the paths to the data that I host and the content-hashes of data that I do not host. 

** Items & Labels

We host or reference items, and we label them as we wish. 

   The point of all this is to get to the point where it makes sense to implement the concept lattice functions & protocols found in this Order Theory book I straight up stole from Multnomah. I promise to pay them back. I have to go in for forgiveness. I also have to ask Eric WVGG if he has that book and if so to mail it to 849 N Farragut toot suite. (Or should he keep it?) 

Another point is to distinguish between my labels and your labels --- to import your labels, disagree with your labels, modify your labels, combine our labels, annote subjunctive labels. To do interesting things with the ways that we reshuffle things by the way that we name them (or perhaps we should say 'multiname them'? nah it'll never catch on). 

Another another point is to take those concept lattice functions, and derive transformations from mathematical work that has been done on them in the abstract. It is my understanding that there are graph drawing methods to represent concepts, subconcepts, and superconcepts in rather continuous ways. That would be a big help in exploring a large collection of items or, dually, a large collection of collections of labels. 

** Network Rethinks

I'm always on the lookout for ways to use p2p concepts and new methods in computronium. FileCoin? Tezos? Akasha? Datasys? Dat Sys? Other experimental services? I'm down to experiment. 
